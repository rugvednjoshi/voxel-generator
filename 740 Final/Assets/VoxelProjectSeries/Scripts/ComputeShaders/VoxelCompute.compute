// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "VoxelValues.cginc"
#include "Voxel.compute"

struct sharedVert
{
    uint index;
    bool set;
};

StructuredBuffer<VoxelDetails> voxelColors;
RWStructuredBuffer<Voxel> voxelArray;
RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<float3> normalBuffer;
RWStructuredBuffer<float4> colorBuffer;
RWStructuredBuffer<int> indexBuffer;
RWStructuredBuffer<int> transparentIndexBuffer;
RWStructuredBuffer<uint> counter;

float3 chunkPosition;

uint chunkSizeX;
uint chunkSizeY;
bool sharedVertices;
bool useTextures;

float packFloats(float xF, float yF)
{
    float2 output = float2(xF, yF);
    output.x = floor(output.x * (100 - 1));
    output.y = floor(output.y * (100 - 1));

    return (output.x * 100) + output.y;
}

float2 unpackFloats(float f)
{
    int input = int(f);

    float x = input >> 8 & 0xff;
    float y = input >> 0 & 0xff;

    return float2(x, y);
}

uint flattenCoord(uint3 idx)
{
    return idx.x + (idx.y * (chunkSizeX + 3)) + (idx.z * (chunkSizeX + 3) * (chunkSizeY + 1));
}

bool VoxelIsSolid(uint3 pos)
{
    return GetVoxelData(0, voxelArray[flattenCoord(pos)].VoxelData) != 0;
}

bool VoxelIsTransparent(uint3 pos)
{
    return GetVoxelData(0, voxelArray[flattenCoord(pos)].VoxelData) == 240;
}

static uint3 getCellCenterForIDX(int idx, int axis, int corner)
{
    uint3 cellCenter = CellCentersByAxis[axis][corner];
    if (voxelVertices[idx].x == 1 && CellCentersByAxis[axis][corner].x == -1)
        cellCenter.x = 1;

    if (voxelVertices[idx].y == 1 && CellCentersByAxis[axis][corner].y == -1)
        cellCenter.y = 1;

    if (voxelVertices[idx].z == 1 && CellCentersByAxis[axis][corner].z == -1)
        cellCenter.z = 1;

    return cellCenter;
}

void calculateContour(uint3 blockCoord, out float3 position, out float3 normal, float3 vertexPos, int idx)
{
    Voxel currentCell, adjacentCell, adjacentRootCell;
    float adjacentCellDensitiy = 0, adjacentRootCellDensity = 0;
    float3 adjacentCellPos;
    float3 adjacentCellRoot;
    float3 liveCellPos;
    int adjacentRootCellId;
    int adjacentCellId;
    uint3 vWorldPos = blockCoord + vertexPos; //take local block coord, add the cubed position
    int counter = 0;
    currentCell = voxelArray[flattenCoord(blockCoord)];
    int currentCellId = GetVoxelData(0, currentCell.VoxelData);

    for (int ax = 0; ax < 3; ax++)
    {
        for (int corner = 0; corner < 4; corner++)
        {
                
            adjacentCellRoot = blockCoord + getCellCenterForIDX(idx, ax, corner);
            adjacentCellPos = adjacentCellRoot + axis[idx][ax];

            adjacentRootCell = voxelArray[flattenCoord(adjacentCellRoot)];
            adjacentCell = voxelArray[flattenCoord(adjacentCellPos)];
            
            adjacentRootCellId = GetVoxelData(0, adjacentRootCell.VoxelData);
            adjacentCellId = GetVoxelData(0, adjacentCell.VoxelData);

            if (adjacentRootCellId == 240 && currentCellId != 240)
                adjacentRootCellId = 0;
            if (adjacentCellId == 240 && currentCellId != 240)
                adjacentCellId = 0;

            if (currentCellId == 240 && adjacentRootCellId != 240)
                adjacentRootCellId = 0;
            if (currentCellId == 240 && adjacentCellId != 240)
                adjacentCellId = 0;

            adjacentRootCellDensity = adjacentRootCellId != 0 ? 1 : 0;
            adjacentCellDensitiy = adjacentCellId != 0 ? 1 : 0;
            
            normal += (adjacentCellDensitiy - adjacentRootCellDensity) * -axis[idx][ax];
            if (adjacentRootCellDensity != adjacentCellDensitiy)
            {
                liveCellPos = adjacentCellId != 0 ? adjacentCellPos : adjacentCellRoot;
                adjacentCellPos = adjacentCellId == 0 ? adjacentCellPos : adjacentCellRoot;
                
                position += adjacentCellPos + ((liveCellPos - adjacentCellPos) * getCellCenterForIDX(idx, ax, corner)) / 2; //lerp(adjacentCellRoot + ((float3) (adjacentCellPos - adjacentCellRoot) * ((0 - adjacentRootCellDensity) / (adjacentCellDensitiy - adjacentRootCellDensity))), vWorldPos, 0); //change 0 to byte value
                counter++;
            }
        }
    }
    
    if (counter == 0)
    {
        position = vWorldPos;
        counter = 1;
    }

    normal = normalize(normal / counter);
    position /= counter;

}

[numthreads(8,8,8)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xz > chunkSizeX) || any(id.xz < 1))
        return;
    
    Voxel block = voxelArray[flattenCoord(id)];
    int blockID = GetVoxelData(0, block.VoxelData);

    if (blockID == 0)
        return;
    
    float3 faceVertices[4];
    float3 faceNorms[4];
    float4 color = float4(blockID == 240 ? 240 :
        (useTextures && voxelColors[blockID - 1].color == -1 ? ((float) blockID - 1) : voxelColors[blockID - 1].color),
        packFloats(voxelColors[blockID - 1].metallic, voxelColors[blockID - 1].smoothness), 0, 0);
    uint vertCount = 0;
    uint triCount = 0;
    
    sharedVert sharedVerts[8];
    for (int i = 0; i < 8; i++)
    {
        sharedVerts[i].set = false;
        sharedVerts[i].index = 0;
    }
    for (int i = 0; i < 6; i++)
    {
        
        //Check if there's a solid block against this face
        if (VoxelIsSolid(id + voxelFaceChecks[i]) && !VoxelIsTransparent(id + voxelFaceChecks[i]))
            continue;

        if (blockID == 240 && VoxelIsTransparent(id + voxelFaceChecks[i]))
            continue;
        
        //Draw this face
        //Collect the appropriate vertices from the default vertices and add the block position
        if (!sharedVertices)
        {
            InterlockedAdd(counter[0], 6, vertCount);
            if (blockID != 240)
                InterlockedAdd(counter[1], 6, triCount);
            else
                InterlockedAdd(counter[2], 6, triCount);
            
            for (int j = 0; j < 4; j++)
            {
                calculateContour(id, faceVertices[j], faceNorms[j], voxelVertices[voxelVertexIndex[i][j]], voxelVertexIndex[i][j]);
                faceVertices[j] += chunkPosition;
            }
        
            for (int k = 0; k < 6; k++)
            {
                vertexBuffer[vertCount + k] = faceVertices[voxelTris[i][k]];
                color.b = voxelUVs[voxelTris[i][k]].x;
                color.a = voxelUVs[voxelTris[i][k]].y;
                colorBuffer[vertCount + k] = color;
                if (blockID != 240)
                    indexBuffer[triCount + k] = vertCount + k;
                else
                    transparentIndexBuffer[triCount + k] = vertCount + k;
            }
        }
        else
        {
            if (blockID != 240)
                InterlockedAdd(counter[1], 6, triCount);
            else
                InterlockedAdd(counter[2], 6, triCount);
            for (int k = 0; k < 6; k++)
            {
                int idx = voxelTrisMapped[i][k];
                if (!sharedVerts[idx].set)
                {
                    InterlockedAdd(counter[0], 1, vertCount);
                    
                    float3 vert;
                    float3 norm;
                    calculateContour(id, vert, norm, voxelVertices[idx], idx);
                    sharedVerts[idx].set = true;
                    sharedVerts[idx].index = vertCount;
                    
                    color.b = voxelUVs[voxelTris[i][k]].x;
                    color.a = voxelUVs[voxelTris[i][k]].y;
                    
                    vertexBuffer[vertCount] = vert + chunkPosition;
                    normalBuffer[vertCount] = norm;
                    colorBuffer[vertCount] = color;
                }
                
                if (blockID != 240)
                    indexBuffer[triCount + k] = sharedVerts[idx].index;
                else
                    transparentIndexBuffer[triCount + k] = sharedVerts[idx].index;
            }

        }
    }
}
    
