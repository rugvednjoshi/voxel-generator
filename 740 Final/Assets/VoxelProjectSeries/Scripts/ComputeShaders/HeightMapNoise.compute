// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel FillArray
#pragma kernel ClearArray

#include "Noise/SimplexNoise.compute"
#include "Noise/HashNoise.compute"
#include "Voxel.compute"

struct NoiseLayer {
    float gain;
    float frequency;
    float lacunarity;
    float persistence;
    int octaves;

    float caveScale;
    float caveThreshold;

    int surfaceVoxelId;
    int subSurfaceVoxelId;
};

StructuredBuffer<NoiseLayer> noiseArray;
RWStructuredBuffer<Voxel> voxelArray;
RWStructuredBuffer<float4> specialBlocksBuffer;
RWStructuredBuffer<uint> count;

float3 chunkPosition;
float3 seedOffset;

uint chunkSizeX;
uint chunkSizeY;

bool generateCaves;
bool forceFloor;

uint maxHeight;
uint oceanHeight;
int noiseCount;
int seed;

int flattenCoord(uint3 idx)
{
    return idx.x + (idx.y * (chunkSizeX + 3)) + (idx.z * (chunkSizeX + 3) * (chunkSizeY + 1));
}

float evaluateNoise(float3 pos, float terrainHeight)
{
    float h = 1;
    float G = exp2(-h);
    float f = 1;
    float a = 1;
    float t = 0;
    
    for (int i = 0; i < 4; i++)
    {
        t += a * snoise(f * (pos / (noiseArray[0].caveScale / ((uint) terrainHeight > oceanHeight ? 1 : 6))));
        f *= 2.0;
        a *= G;
    }
    return t;
}

float fractalNoise(float2 pos, int noisePosition)
{
    float v = 0;
    float amplitude = 1;
    
    NoiseLayer b = noiseArray[noisePosition];
    float3 p1 = float3(pos.xy, seed);
    for (int i = 0; i < noiseArray[noisePosition].octaves; i++)
    {
        v += snoise(float3(p1.xy / b.frequency, seed)) * amplitude;

        p1.xy *= b.lacunarity;
        
        amplitude *= b.persistence;
    }
    v = v * v;
    return clamp(v, 0, 1);
}



bool sampleHeightAtPoint(float2 pos, out uint terrainHeight, out uint noiseIndex) {
    float height = 0;

    float strongestWeight = 0;

    uint count = 0;
    float heightWeight;
    int i = 0;

    float weightH = fractalNoise(pos, i);
    height = clamp((weightH * 240), 0, 250);

    noiseIndex = 0;
    terrainHeight = round(height);
    return true;
}

[numthreads(8, 8, 8)]
void FillArray(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xz > chunkSizeX + 2))
        return;
    
    float3 pos = id + chunkPosition + seedOffset;
    float2 posXZ = pos.xz;
    
    if (GetVoxelData(0, voxelArray[flattenCoord(id)].VoxelData) != 0)
        return;

    uint terrainHeight;
    uint noiseIndex;
    sampleHeightAtPoint(posXZ, terrainHeight, noiseIndex);
    NoiseLayer selectednoise = noiseArray[noiseIndex];

    Voxel vox;
    vox.VoxelData = 0;
    int voxelId = 0;

    if (id.y > terrainHeight)
    {
        voxelId = 0;
        
        if (voxelId == 0 && id.y <= 2)
        {
            voxelId = 240;
            InterlockedAdd(count[0], 1);
        }
        
        UpdateVoxelData(0, voxelId, vox.VoxelData);
        voxelArray[flattenCoord(id)] = vox;
        return;
    }

    bool isSurfaceBlock = id.y >= terrainHeight - 3;

    voxelId = isSurfaceBlock ? selectednoise.surfaceVoxelId : selectednoise.subSurfaceVoxelId;
    
    if (generateCaves && evaluateNoise(pos, terrainHeight) > selectednoise.caveThreshold)
    {
        voxelId = 0;
    }

    if (id.y <= 1 && forceFloor)
        voxelId = selectednoise.surfaceVoxelId;


    if (voxelId != 0)
        InterlockedAdd(count[0], 1);

    if (id.y == terrainHeight && voxelId != 0 && id.y < 240)
    {
        bool placeFoliage = noise(float3(posXZ * 2, seed)) > 0.999;

        if (placeFoliage)
        {
            int typeOf = noise(float3(pos.xz * 25, seed)) * 75;
            int foliageID;
            if (typeOf < 30)
                foliageID = 243;
            else if (typeOf < 45)
            {
                bool canSpawnTree = true;
                uint tHeight, index;
                for (int x = -1; x <= 1; x++)
                    for (int z = -1; z <= 1; z++)
                        if (sampleHeightAtPoint(posXZ + float2(x, z), tHeight, index) && tHeight != terrainHeight)
                            canSpawnTree = false;

                if (canSpawnTree)
                    foliageID = 244;
                else
                    foliageID = 0;
            }
            else if (typeOf < 75)
                foliageID = 245;

            int counter = 0;

            if (foliageID != 0) {
                InterlockedAdd(count[1], 1, counter);
                specialBlocksBuffer[counter] = float4(id + float3(0, 1, 0), foliageID);
            }
        }
    }
    
    UpdateVoxelData(0, voxelId, vox.VoxelData);
    voxelArray[flattenCoord(id)] = vox;
}

[numthreads(8, 8, 8)]
void ClearArray(uint3 id : SV_DispatchThreadID)
{
    Voxel emptyVoxel;
    emptyVoxel.VoxelData = 0;
    voxelArray[flattenCoord(id)] = emptyVoxel;
}